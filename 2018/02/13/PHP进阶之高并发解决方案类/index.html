<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="PHP,网站优化,负载均衡," />










<meta name="description" content="1.高并发和大流量解决方案1.回顾真题:PHP如何解决网站大流量与高并发的问题？考官考点:高并发架构相关概念，高并发解决方案案例 2.高并发架构相关概念并发:在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。我们所说的高并发：在互联网领域，并发、高并发通常是指并发访问；即在某个时间点，有多少个访">
<meta name="keywords" content="PHP,网站优化,负载均衡">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP进阶之高并发解决方案类">
<meta property="og:url" content="http://yoursite.com/2018/02/13/PHP进阶之高并发解决方案类/index.html">
<meta property="og:site_name" content="全蛋的博客">
<meta property="og:description" content="1.高并发和大流量解决方案1.回顾真题:PHP如何解决网站大流量与高并发的问题？考官考点:高并发架构相关概念，高并发解决方案案例 2.高并发架构相关概念并发:在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。我们所说的高并发：在互联网领域，并发、高并发通常是指并发访问；即在某个时间点，有多少个访">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s1.ax1x.com/2018/03/04/9yBBHP.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/03/04/9yjPJK.png">
<meta property="og:updated_time" content="2018-03-30T08:51:53.108Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHP进阶之高并发解决方案类">
<meta name="twitter:description" content="1.高并发和大流量解决方案1.回顾真题:PHP如何解决网站大流量与高并发的问题？考官考点:高并发架构相关概念，高并发解决方案案例 2.高并发架构相关概念并发:在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。我们所说的高并发：在互联网领域，并发、高并发通常是指并发访问；即在某个时间点，有多少个访">
<meta name="twitter:image" content="https://s1.ax1x.com/2018/03/04/9yBBHP.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/02/13/PHP进阶之高并发解决方案类/"/>





  <title>PHP进阶之高并发解决方案类 | 全蛋的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">全蛋的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/13/PHP进阶之高并发解决方案类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fullegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="全蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">PHP进阶之高并发解决方案类</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-13T18:11:25+08:00">
                2018-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-高并发和大流量解决方案"><a href="#1-高并发和大流量解决方案" class="headerlink" title="1.高并发和大流量解决方案"></a>1.高并发和大流量解决方案</h1><h2 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1.回顾"></a>1.回顾</h2><p>真题:PHP如何解决网站大流量与高并发的问题？<br>考官考点:高并发架构相关概念，高并发解决方案案例</p>
<h2 id="2-高并发架构相关概念"><a href="#2-高并发架构相关概念" class="headerlink" title="2.高并发架构相关概念"></a>2.高并发架构相关概念</h2><p>并发:在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。<br>我们所说的高并发：在互联网领域，并发、高并发通常是指并发访问；即在某个时间点，有多少个访问同时到来；通常一个系统大的日PV在千万以上，有可能是个高并发的系统。<br>QPS：每秒钟请求或者查询的数量，在互联网领域，指每秒响应请求书（指HTTP请求）<br>吞吐量：单位时间内处理的请求数量（通常由QPS与并发数决定）<br>响应时间：从请求发出到收到响应花费的时间。例如系统处理一个HTTP请求需要100ms，这个100ms就是系统的响应时间<br>PV：综合浏览器（Page View），即页面浏览量或者点击量，一个访客在24小时内访问的页面数量；同一个访客浏览网站的同一页面，只记作一次PV<br>UV：独立访客（Unique Visitor），即一定时间范围内相同访客多次访问网站，只计算为1个独立访客<br>带宽：计算带宽大小需要关心两个指标，峰值流量和页面平均大小<br>日网站带宽 = PV / 统计时间(换算到秒) * 平均页面大小(单位KB) * 8<br>(总PV数 * 80%) / (6小时秒数 * 20%) = 峰值每秒请求数(QPS)<br>二八定律：80%的访问量都集中在20%的访问时间<br>峰值一般是平均值的倍数，根据实际情况来定<br>QPS ≠ 并发连接数，QPS是每秒HTTP请求数量，并发连接数是系统同时处理的请求数量<br>压力测试：测试能承受的最大并发数，测试最大承受的QPS值<br>常用性能测试工具：ab、wrk、http_load、Web Bench、Siege、Apache JMeter<br>ab:apache benchmark，是apache官方推出的工具；创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此它既可以测试apach的负载压力，也可以测试nginx、lighthttp、tomact、IIS等其他web服务器的压力；ab -c 100 -n 5000 待测试网站<br>测试注意事项：测试机器与被测试机器分开；不要对线上服务做压力测试；观察测试工具ab所在机器，以及被测试的前端机的CPU，内存，网络等丢不超过最高限度的75%<br>QPS达到极限：随着QPS的增长，每个阶段需要根据实际情况来进行优化，优化的方案也与硬件条件、网络带宽息息相关。<br>QPS达到50：可以称之为小型网站，一般的服务器就可以应付<br>QPS达到100：假设关系型数据库的每次请求在0.01秒完成；假设单页面只有一个SQL查询，那么100QPS意味着1秒钟完成100次请求，但是此时我们并不能保证数据库查询能完成100次；优化方案：数据库缓存层、数据库的负载均衡<br>QPS达到800：假设我们使用百兆带宽，意味着网站出口的实际带宽是8M左右；假设每个页面只有10K，在这个并发条件下，百兆带宽就已经用完；优化方案：CDN加速、负载均衡<br>QPS达到1000：假设使用Memcache缓存数据库查询数据，每个页面对Memcache的请求远大于直接对DB的请求；Memcache的悲观并发数在2w左右，但有可能在之前内网带宽已经用完，表现出不稳定；优化方案：静态HTML缓存<br>QPS达到2000：这个级别下，文件系统访问锁都成为了灾难；优化方案：做业务分类，分布式存储</p>
<h2 id="3-高并发解决方案案例"><a href="#3-高并发解决方案案例" class="headerlink" title="3.高并发解决方案案例"></a>3.高并发解决方案案例</h2><p>流量优化：防盗链处理<br>前端优化：减少HTTP请求(合并css js 图片)，添加异步请求(不重要的信息转为ajax)，启用浏览器的缓存和文件压缩，CDN加速，建立独立的图片服务器<br>服务端优化：页面静态化(如laravel框架自带缓存)，并发处理(多线程处理)，队列处理<br>数据库优化：数据库缓存memcache redis，分库分表、分区操作，读写分离，负载均衡<br>web服务器优化：负载均衡nginx反向代理、LVS<br><br><br><br></p>
<h1 id="2-web资源防盗链"><a href="#2-web资源防盗链" class="headerlink" title="2.web资源防盗链"></a>2.web资源防盗链</h1><h2 id="1-什么是防盗链"><a href="#1-什么是防盗链" class="headerlink" title="1.什么是防盗链"></a>1.什么是防盗链</h2><p>盗链：在自己的页面上展示一些并不在自己服务器上的内容；获得他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向最终用户提供此内容；常见的是小站盗用大站的图片、音乐、视频、软件等资源；通过盗链的方法可以减轻自己服务器的负担，因为真实的空间和流量均是来自别人的服务器。<br>防盗链：防止别人通过一些技术手段绕过本站的资源展示页面，盗用本站的资源，让绕开本站资源展示页面的资源链接失效；可以大大减轻服务器及带宽的压力。</p>
<h2 id="2-防盗链的工作原理"><a href="#2-防盗链的工作原理" class="headerlink" title="2.防盗链的工作原理"></a>2.防盗链的工作原理</h2><p>通过referer或者签名，网站可以检测目标网页访问的来源网页，如果是资源文件，则可以跟踪到显示它的网页地址。<br>一旦检测到来源不是本站，即进行阻止或者返回指定的页面。<br>通过计算签名的方式，判断请求是否合法，如果合法则显示，否则返回错误信息。</p>
<h2 id="3-通过Referer实现防盗链"><a href="#3-通过Referer实现防盗链" class="headerlink" title="3.通过Referer实现防盗链"></a>3.通过Referer实现防盗链</h2><p>Referer：nginx模块 ngx_http_referer_module 用于阻挡来源非法的域名请求；nginx指令valid_referers，全局变量$invalid_referer<br>valid_referers none | blocked | server_names | string …;<br>none:”Referer”来源头部为空的情况<br>blocked:”Referer”来源头部不为空，但是里面的值被代理或者防火墙删除了，这些值都不以http://或者https://开头<br>server_names:”Referer”来源头部包含当前的server_names<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location ~.*\.(gif|jpg|png|flv|swf|rar|zip)$</span><br><span class="line">&#123;</span><br><span class="line">	valid_referers none blocked 本站localhost；</span><br><span class="line">	if($invalid_referer)</span><br><span class="line">	&#123;</span><br><span class="line">		#return 403;</span><br><span class="line">		rewrite ^/ http://localhost/403.jpg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Referer还可以对目录进行防盗链</p>
<h2 id="4-通过第三方模块加密签名实现防盗链"><a href="#4-通过第三方模块加密签名实现防盗链" class="headerlink" title="4.通过第三方模块加密签名实现防盗链"></a>4.通过第三方模块加密签名实现防盗链</h2><p>解决了伪造Referer<br>使用第三方模块HttpAccessKeyModule实现nginx防盗链<br>accesskey on|off 模块开关<br>accesskey_hashmethod md5|sha-1签名加密方式<br>accesskey_arg GET参数名称<br>accesskey_signature 加密规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~.*\.(gif|jpg|png|flv|swf|rar|zip)$</span><br><span class="line">&#123;</span><br><span class="line">	accesskey on;</span><br><span class="line">	accesskey_hashmethod md5;</span><br><span class="line">	accesskey_arg &quot;key&quot;;</span><br><span class="line">	accesskey_signature &quot;mypass$remote_addr&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-减少HTTP请求次数"><a href="#3-减少HTTP请求次数" class="headerlink" title="3.减少HTTP请求次数"></a>3.减少HTTP请求次数</h1><h2 id="1-为什么要减少HTTP请求"><a href="#1-为什么要减少HTTP请求" class="headerlink" title="1.为什么要减少HTTP请求"></a>1.为什么要减少HTTP请求</h2><p>性能黄金法则：只有10%~20%的最终用户响应时间花在接受请求的HTML文档上，剩下的80%~90%时间花在HTML文档所引用的所有组件（图片、script、css、flash等等）进行的HTTP请求上。<br>如何改善：改善响应时间的最简单途径就是减少组件的数量，并由此减少HTTP请求的数量。<br>HTTP连接产生的开销：域名解析–TCP连接–发送请求–等待–下载资源–解析时间<br>DNS缓存不靠谱：查找DNS缓存也需要时间，多个缓存就要查找多次，有可能缓存会被清除<br>HTTP1.1协议规定请求只能串行发送，也就是说一百个请求必须依次逐个发送，前面的一个请求完成才能开始下一个请求</p>
<h2 id="2-减少HTTP请求的方式"><a href="#2-减少HTTP请求的方式" class="headerlink" title="2.减少HTTP请求的方式"></a>2.减少HTTP请求的方式</h2><p>图片地图：图片地图允许你在一个图片上关联多个URL；目标URL的选择取决于用户单击了图片上的哪个位置；使用<map><area></map>标签。<br>CSS Sprites：CSS精灵，通过使用合并图片，指定css的background-image和background-position来显示元素。<br>性能影响：图片地图与CSS精灵的响应时间基本上相同，但比使用各自独立图片的方式要快50%以上。<br>合并脚本和样式表：使用外部的js和css文件引用的方式，因为这要比直接写在页面中性能要更好一点；独立的一个js比用多个js文件组成的页面载入要快38%；把多个脚本合并为一个脚本，把多个样式表合并为一个样式表。<br>图片使用Base64编码减少页面请求数：采用Base64的编码方式将图片直接嵌入到网页中，而不是外部载入；<code>&lt;img src=&quot;data:image/gif;base64,abc...&quot;/&gt;</code><br><br><br><br></p>
<h1 id="4-浏览器缓存和压缩优化技术"><a href="#4-浏览器缓存和压缩优化技术" class="headerlink" title="4.浏览器缓存和压缩优化技术"></a>4.浏览器缓存和压缩优化技术</h1><h2 id="1-HTTP缓存机制"><a href="#1-HTTP缓存机制" class="headerlink" title="1.HTTP缓存机制"></a>1.HTTP缓存机制</h2><p>缓存分类:HTTP缓存模型中,如果请求成功会有三种情况.<br>200 from cache:直接从本地缓存中获取响应,最快速,最省流量,因为根本没有向服务器发送请求.<br>304 not modified:协商缓存,浏览器在本地没有命中的情况下请求头中发送一定的校验数据到服务端,如果服务端数据没有改变,浏览器从本地缓存响应,返回304;快速,发送的数据很少,只返回一些基本的响应头信息,数据量很小,不发送实际响应体.<br>200 OK:以上两次缓存全都失败,服务器返回完整的响应.没有用到缓存,相对最慢.</p>
<h2 id="2-本地缓存"><a href="#2-本地缓存" class="headerlink" title="2.本地缓存"></a>2.本地缓存</h2><p>浏览器认为本地缓存可以使用,就不会去请求服务端.<br>pragma:HTTP1.0时代的遗留产物,该字段被设置为no-cache时,会告知浏览器禁用本地缓存,即每次都向服务器发送请求.<br>expires:HTTP1.0时代用来启用本地缓存的字段,expires值对应一个形如 Thu,31 Dec 2037 23:55:55 GMT的格林威治时间,告诉浏览器缓存实现的时刻,如果还没到该时刻,表示缓存有效,无需发送请求.<br>浏览器与服务器的时间无法保持一致,如果时间差距大,就会影响缓存结果.<br>cache-control:HTTP1.1针对Expires时间不一致的解决方案,运用cache-control告知浏览器缓存过期的时间间隔而不是时刻,即使具体时间不一致,也不影响缓存的管理.<br>cache-control:no-store 禁止浏览器缓存响应;no-cache 不允许直接使用本地缓存,先发起请求和服务器协商;max-age=dalta-seconds 告知浏览器该响应本地缓存有效的最长时限,以秒为单位.<br>优先级: pragma &gt; cache-control &gt; expires</p>
<h2 id="3-协商缓存"><a href="#3-协商缓存" class="headerlink" title="3.协商缓存"></a>3.协商缓存</h2><p>当浏览器没有命中本地缓存,如本地缓存过期或者响应中声明不允许直接使用本地缓存,那么浏览器肯定会发起服务端请求.<br>服务端会验证数据是否修改,如果没有修改,通知浏览器使用本地缓存.<br>last-modified:通知浏览器资源的最后欧修改时间.<br>if-modified-since:得到资源的最后修改时间后,会将这个信息通过if-moodifed-since提交到服务器做检查,如果没有修改,返回304状态码.<br>etag:HTTP1.1推出,文件的指纹标识符,如果文件内容修改,指纹会改变.<br>if-none-match:本地缓存失效,会携带此值去请求服务端,服务端判断该资源是否改变,如果没有改变,直接使用本地缓存,返回304.</p>
<h2 id="4-缓存策略的选择"><a href="#4-缓存策略的选择" class="headerlink" title="4.缓存策略的选择"></a>4.缓存策略的选择</h2><p>适合缓存的内容:不变的图片,如logo,图标等;js css静态文件;可下载的内容,媒体文件.<br>建议使用协商缓存:HTML文件,经常替换的图片,经常修改的js css文件.<br>不建议缓存的内容:用户隐私等敏感数据,经常改变的api数据接口.</p>
<h2 id="5-nginx配置缓存策略"><a href="#5-nginx配置缓存策略" class="headerlink" title="5.nginx配置缓存策略"></a>5.nginx配置缓存策略</h2><p>add_header指令:添加状态码为2XX和3XX的响应信息<br>add_header name value [always]<br>可以设置Pragma/Cache-Control/Expires,可以继承<br>expires指令:通知浏览器过期时长;expires time;time为负表示cache-control:no-cache,为正或者0表示cache-control:max-age=指定的时间,为max表示Cache-Control设置到10年.<br>协商缓存相关配置:etag指令: etag on|off</p>
<h2 id="6-前端代码和资源的压缩"><a href="#6-前端代码和资源的压缩" class="headerlink" title="6.前端代码和资源的压缩"></a>6.前端代码和资源的压缩</h2><p>优势:让资源文件更小,加快文件在网络中的传输,让网页更快的展现,降低带宽和流量开销<br>压缩方式:js css 图片 HTML代码的压缩,Gzip压缩<br>JavaScript代码压缩:JavaScript压缩的原理一般是去掉多余的空格和回车,替换长变量名,简化一些代码写法等;JavaScript代码压缩工具很多;常用压缩工具:UglifyJS / YUI Compressor / Closure / Compiler.<br>css代码压缩:原理同js,同样是去除空白符/注释并且优化一些css语义规则等.<br>HTML代码压缩:不建议使用代码压缩,有时会破坏代码结构,可以使用Gzip压缩,当然也可以使用htmlcompressor工具,不过转换后一定要检查代码结构.<br>图片压缩:一般情况下图片在web系统的比重都比较大.压缩工具:tinypng/JpegMini/ImageOptim<br>nginx配置Gzip:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gzip on|off; #是否开启gzip</span><br><span class="line">gzip_buffers 32 4K| 16 8K #缓存(在内存中缓存几块?每块多大)</span><br><span class="line">gzip_comp_level[1-9] #推荐6 压缩级别越高压的越小,越浪费CPU计算资源</span><br><span class="line">gzip_disable #正则匹配UA 不进行gzip的URI</span><br><span class="line">gzip_min_length 200 #开始压缩的最小长度</span><br><span class="line">gzip_http_version 1.0|1.1 #开始压缩的HTTP协议版本</span><br><span class="line">gzip_proxied #设置请求代理服务,该如何缓存内容</span><br><span class="line">gzip_types text/plain application/xml #对哪些类型的文件用压缩</span><br><span class="line">gzip_vary on|off #是否传输gzip压缩标志</span><br></pre></td></tr></table></figure></p>
<p>其他工具:前端自动化构建工具Grunt<br><br><br><br></p>
<h1 id="5-CDN加速"><a href="#5-CDN加速" class="headerlink" title="5.CDN加速"></a>5.CDN加速</h1><h2 id="1-CDN相关概念"><a href="#1-CDN相关概念" class="headerlink" title="1.CDN相关概念"></a>1.CDN相关概念</h2><p>CDN的全称是Content Delivery Network,即内容分发网络.<br>尽可能避开互联网上有可能影响传输速度和稳定性的瓶颈和环节,是内容传输更快更稳定.<br>在网络各处放置节点服务器,在现有的网络基础上构成一层智能的虚拟网络.<br>CND系统能够实时地根据网络流量和各节点的连接,负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用最近的服务节点上.</p>
<h2 id="2-使用CDN的优势"><a href="#2-使用CDN的优势" class="headerlink" title="2.使用CDN的优势"></a>2.使用CDN的优势</h2><p>本地cache加速,提高企业站点的访问速度.<br>跨运营商的网络加速,保证不同网络的用户都得到良好的访问质量.<br>远程用户根据DNS负载均衡技术智能自动选择cache服务器.<br>自动生成服务器的镜像缓存服务器,远程用户访问时从cache服务器上读取数据,减少远程访问的带宽,分担网络流量,减轻原站点web服务器负载等功能.<br>广泛分布的CDN节点加上节点之间的智能冗余机制,可以有效的预防黑客入侵.</p>
<h2 id="3-CDN工作原理"><a href="#3-CDN工作原理" class="headerlink" title="3.CDN工作原理"></a>3.CDN工作原理</h2><p><img src="https://s1.ax1x.com/2018/03/04/9yBBHP.png" alt=""></p>
<h2 id="4-CDN使用场景"><a href="#4-CDN使用场景" class="headerlink" title="4.CDN使用场景"></a>4.CDN使用场景</h2><p>站点或者应用中大量静态资源的加速分发,例如:CSS,js,图片和HTML<br>大文件下载<br>直播网站等等</p>
<h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5.实现"></a>5.实现</h2><p>BAT等都有提供CDN服务<br>可用LVS做4层负载均衡<br>可用nginx,varnish,squid,apache trafficserver做7层负载均衡和cache<br>使用squid反向代理,或nginx的反向代理<br><br><br><br></p>
<h1 id="6-部署独立图片服务器"><a href="#6-部署独立图片服务器" class="headerlink" title="6.部署独立图片服务器"></a>6.部署独立图片服务器</h1><h2 id="1-独立的必要性"><a href="#1-独立的必要性" class="headerlink" title="1.独立的必要性"></a>1.独立的必要性</h2><p>分担web服务器的I/O负载-将耗费资源的图片服务分离出来,提高服务器的性能和稳定性.<br>能够专门对图片服务器进行优化,为图片服务器设置有针对性的缓存方案(提高硬盘转速,降低cpu频率),减少带宽成本,提高访问速度.<br>提高网站的可扩展向,通过增加图片服务器,提高图片吞吐能力.</p>
<h2 id="2-采用独立域名"><a href="#2-采用独立域名" class="headerlink" title="2.采用独立域名"></a>2.采用独立域名</h2><p>同一域名下浏览器的并发连接数有限制,一般2-6个.<br>由于cookie的原因,对缓存不利,大部分web cache都只缓存不带cookie的请求,导致每次的图片请求都不能命中cache.</p>
<h2 id="3-独立后的问题"><a href="#3-独立后的问题" class="headerlink" title="3.独立后的问题"></a>3.独立后的问题</h2><p>如何进行图片上传和图片同步:NFS共享方式,利用FTP同步<br><br><br><br></p>
<h1 id="7-动态语言静态化"><a href="#7-动态语言静态化" class="headerlink" title="7.动态语言静态化"></a>7.动态语言静态化</h1><h2 id="1-什么是动态语言静态化"><a href="#1-什么是动态语言静态化" class="headerlink" title="1.什么是动态语言静态化"></a>1.什么是动态语言静态化</h2><p>将现有PHP等动态语言的逻辑代码生成为静态HTML文件,用户访问动态脚本重定向到静态HTML文件的过程.<br>对实时性要求不高的页面可以静态化.</p>
<h2 id="2-为什么要静态化"><a href="#2-为什么要静态化" class="headerlink" title="2.为什么要静态化"></a>2.为什么要静态化</h2><p>动态脚本通常会做逻辑计算和数据查询,访问量越大,服务器压力越大.<br>访问量大时可能会造成CPU负载过高,数据库服务器压力过大.<br>静态化可以减低逻辑处理压力,降低数据库服务器查询压力.</p>
<h2 id="3-静态化的实现方式"><a href="#3-静态化的实现方式" class="headerlink" title="3.静态化的实现方式"></a>3.静态化的实现方式</h2><p>使用模板(PHP框架)引擎实现静态化<br>利用ob系列函数实现静态化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ob_start(); // 打开输出控制缓冲</span><br><span class="line">ob_get_contents(); // 返回输出缓冲区内容</span><br><span class="line">ob_clean(); // 清空输出缓冲区</span><br><span class="line">ob_end_flush(); // 冲刷出输出缓冲区内容并关闭缓冲</span><br></pre></td></tr></table></figure></p>
<p>可以判断文件的inode修改时间,判断是否过期,使用filectime函数.<br><br><br><br></p>
<h1 id="8-动态语言的并发处理"><a href="#8-动态语言的并发处理" class="headerlink" title="8.动态语言的并发处理"></a>8.动态语言的并发处理</h1><h2 id="1-什么是进程-线程-协程"><a href="#1-什么是进程-线程-协程" class="headerlink" title="1.什么是进程,线程,协程"></a>1.什么是进程,线程,协程</h2><h3 id="进程-process"><a href="#进程-process" class="headerlink" title="进程(process)"></a>进程(process)</h3><p>计算机中的程序关于某数据集合上的一层运行活动,是系统进行资源分配和调度的基本单位,是操作系统结构的基础.即一个”执行中的程序”.</p>
<h3 id="进程的三态模型-运行-就绪-阻塞"><a href="#进程的三态模型-运行-就绪-阻塞" class="headerlink" title="进程的三态模型(运行 就绪 阻塞)"></a>进程的三态模型(运行 就绪 阻塞)</h3><p>多道程序系统中,进程在处理器上交替运行,状态不断地发生变化.<br>运行:当一个进程在处理机上运行时,则称该进程处于运行状态.处于此状态的进程的数目小于等于处理器的数目,对于单处理机系统,处于运行状态的进程只有一个.在没有其他进程可以执行时(如所有进程都在阻塞状态),通常会自动执行系统的空闲进程.<br>就绪:当一个进程获得了除处理机以外的一切所需资源,一旦得到处理机即可运行,则称此进程处于就状态.就绪进程可以按多个优先级来划分队列.例如,当一个进程由于时间片用完而进入就绪状态是,排入低优先级队列;当进程有I/O操作完成而进入就绪状态时,排入高优先级队列.<br>阻塞:也称等待或睡眠状态.一个进程正在等待某一事件发生(例如请求I/O而等待I/O完成等)而暂时停止运行,这时即使把处理机分配给进程也无法运行,故称该进程处于阻塞状态.</p>
<h3 id="进程的五态模型"><a href="#进程的五态模型" class="headerlink" title="进程的五态模型"></a>进程的五态模型</h3><p>对于一个实际的系统,进程的状态及其转换更为复杂.<br>新建态 活跃就绪/静止就绪 运行 活跃阻塞/静止阻塞 终止态<br>新建态:对应于进程刚刚被创建时没有被提交的状态,并等待系统完成创建进程的所有必要信息.<br>活跃就绪:是指进程在主内存中,且可被调度的状态.<br>静止就绪(挂起就绪):是指进程被对换到辅存时的就绪状态,是不能被直接调度的状态,只有当主存中没有活跃就绪态进程,或者是挂起就绪态进程具有更高的优先级,系统将把挂起就绪态进程调回主存并转换为活跃就绪.<br>活跃阻塞:指进程已在主存,一旦等待的事件产生便进入活跃就绪状态.<br>静止阻塞:进程对换到辅存时的阻塞状态,一旦等待的事件产生便进入静止就绪状态.<br>终止态:进程已结束运行,回收除进程控制块之外的其他资源,并让其他进程从进程控制块中收集有关信息.<br>由于用户的并发请求,为每一个请求都创建一个进程显然是行不通的,从系统资源开销方面或是响应用户请求的效率方面来看.因此操作系统中线程的概念便被引进了.</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>有时被称为轻量级进程(Lightweight Process,LWP),是程序执行流的最小单元.<br>线程是进程中的一个实体,是被系统独立调度和分派的基本单位,线程自己不拥有系统资源,只拥有一点儿在运行中必不可少的资源,但它可与同属一个进程的其他线程共享进程所拥有的全部资源.<br>一个线程可以创建和撤销另一个线程,同一进程中的多个线程之间可以并发执行.<br>线程是程序中一个单一的顺序控制流程,进程内一个相对独立的,可调度的执行单元.是系统独立调度和分派CPU的基本单位(指运行中的程序调度单位).<br>在单个程序中同时运行多个线程完成不同的工作,称为多线程.<br>每一个程序都至少有一个线程,若程序只有一个线程,那就是程序本身.<br>线程的状态:就绪 阻塞 运行.<br>就绪状态:线程具备运行的所有条件,逻辑上可以运行,在等待处理机.<br>运行状态:线程占有处理机,正在运行.<br>阻塞状态:线程在等待一个事件(如某个信号量),逻辑上不可执行.</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>一种用户态的轻量级线程,协程的调度完全有用户控制.协程拥有自己的寄存器上下文和栈.协程调度切换时,将寄存器上下文和栈保存到其他地方,在切回来的时候,恢复先保存的寄存器上下文和栈,直接操作栈则基本没有内核切换的开销,可以不加锁的访问全局变量,所以上下文的切换非常快.</p>
<h2 id="2-线程与进程的区别"><a href="#2-线程与进程的区别" class="headerlink" title="2.线程与进程的区别"></a>2.线程与进程的区别</h2><p>线程是进程内的一个执行单元,进程内至少有一个线程,它们共享进程的地址空间,而进程有自己独立的地址空间.<br>进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源.<br>线程是处理器调度的基本单位,但进程不是<br>二者均可并发执行<br>每个独立的线程有一个程序运行的入口,顺序执行序列和程序的出口,但是线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制.</p>
<h2 id="3-线程与协程的区别"><a href="#3-线程与协程的区别" class="headerlink" title="3.线程与协程的区别"></a>3.线程与协程的区别</h2><p>一个线程可以有多个协程,一个进程也可以单独拥有多个协程.<br>线程进程都是同步机制,而协程则是异步.<br>协程能保留上一次调用时的状态,每次过程重入时,就相当于进入上一次调用的状态.</p>
<h2 id="4-什么是多进程-多线程"><a href="#4-什么是多进程-多线程" class="headerlink" title="4.什么是多进程,多线程"></a>4.什么是多进程,多线程</h2><p>同一个时间里,同一个计算机系统中如果允许两个或两个以上的进程处于运行状态,这就是多进程.多开一个进程,就会多分配一份资源,进程间通讯不方便.<br>线程就是把一个进程分为很多片,每一片都可以是一个独立的流程.<br>与多进程的区别是只会使用一个进程的资源,线程间可以直接通信.</p>
<h2 id="5-同步阻塞模型"><a href="#5-同步阻塞模型" class="headerlink" title="5.同步阻塞模型"></a>5.同步阻塞模型</h2><p>多进程:最早的服务器端程序都是通过多进程,多线程来解决并发IO的问题;一个请求创建一个进程,然后子进程进入循环同步阻塞地与客户端连接进行交互,收发处理数据.<br>多线程:用多线程模式实现非常简单,线程中可以直接向某一个客户端连接发送数据.</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h3><p>创建一个socket<br>进入while循环,阻塞在进程accept操作上,等待客户端连接进入.<br>主进程在多进程模型下通过fork创建子进程(多线程模型下也可以创建子线程)<br>子进程/子线程创建成功后进入while循环,阻塞在recv调用上,等待客户端向服务器发送数据.<br>收到数据后,服务器程序进行处理,然后使用send向客户端发送响应.<br>当客户端连接关闭时,子进程/子线程退出并销毁所有资源.主进程/主线程会回收掉此子进程/子线程.<br>缺点:这种模型严重依赖进程的数量解决并发问题;启动大量进程会带来额外的进程调度消耗.</p>
<h2 id="6-异步非阻塞模型"><a href="#6-异步非阻塞模型" class="headerlink" title="6.异步非阻塞模型"></a>6.异步非阻塞模型</h2><p>现在各种高并发异步IO的服务器程序都是基于epoll(linux 2.6 内核已提供)实现的.<br>IO复用异步非阻塞程序使用经典的reactor模型,reactor就是反应堆的意思,它本身不处理任何数据收发.只是可以监视一个socket句柄的事件变化.<br>reactor 4个核心操作如下<br><img src="https://s1.ax1x.com/2018/03/04/9yjPJK.png" alt=""><br>常见的reactor模型:nginx多线程,swoole多线程+多进程<br><br><br><br></p>
<h2 id="7-PHP并发编程实践"><a href="#7-PHP并发编程实践" class="headerlink" title="7.PHP并发编程实践"></a>7.PHP并发编程实践</h2><h3 id="PHP的swoole扩展"><a href="#PHP的swoole扩展" class="headerlink" title="PHP的swoole扩展"></a><a href="https://www.swoole.com/" target="_blank" rel="noopener">PHP的swoole扩展</a></h3><p>PHP的异步,并行,高性能网络通信引擎,使用纯C语言编写,提供了PHP语言的异步多线程服务器,异步TCP/UDP网络客户端,异步MySQL,异步redis,数据库连接池,asyncTask,消息队列,毫秒定时器,异步文件读写,异步DNS查询.<br>除了异步IO的支持之外,swoole为PHP多进程的模式设计了多个并发数据结构和IPC通信机制,可以大大简化多进程并发编程的工作.<br>swoole 2.0支持了类似Go语言的协程,可以使用完全同步的代码实现异步程序.<br>swoole的异步MySQL实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$db = new Swoole\Mysql;</span><br><span class="line">$server = array(&apos;host&apos;=&gt;&apos; &apos;,&apos;user&apos;=&gt; &apos; &apos;,&apos;password&apos;=&gt;&apos; &apos;,&apos;database&apos;=&gt;&apos; &apos;);</span><br><span class="line">$db-&gt;connect($server,function($db,$result)&#123;</span><br><span class="line">	$db-&gt;query(&apos;show tables&apos;, function(Swoole\Mysql $db, $result) &#123;</span><br><span class="line">		//do some thing</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>场景说明:用户注册后,需要发注册邮件和注册短信<br>串行方式:将注册信息写入数据库成功后,发送注册邮件,再发送注册短信.<br>并行方式:将注册信息写入数据库成功后,发送注册邮件的同事,发送注册短信.<br>消息队列方式:将注册信息写入数据库成功后,将成功信息写入队列,此时直接返回成功给用户,写入队列的时间非常短,可以忽略不计,然后异步发送邮件和短信.</p>
<h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>场景说明:用户下单后,订单系统需要通知库存系统.<br>加入库存系统无法访问,则订单减库存将失败,从而导致订单失败.订单系统与库存系统耦合.<br>引用队列:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功.<br>订阅下单的消息,采用拉/推的方式,获取下单信息,库存系统根据下单信息,进行库存操作.</p>
<h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>应用场景:秒杀活动,流量瞬时激增,服务器压力大.<br>用户发起请求,服务器接收后,先写入消息队列.假入消息队列长度超过最大值,则直接报错或提示用户.<br>后续程序读取消息队列再做处理;控制请求量,缓解高流量.</p>
<h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>应用场景:解决大量日志的传输<br>日志采集程序将程序写入消息队列,然后通过日志处理程序的订阅,消费日志.</p>
<h3 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h3><p>应用场景:聊天室<br>多个客户端订阅同一主题,进行消息发布和接受</p>
<h3 id="常见消息队列产品"><a href="#常见消息队列产品" class="headerlink" title="常见消息队列产品"></a>常见消息队列产品</h3><p>kafka activeMQ zeroMQ rabbitMQ redis等</p>
<h3 id="接口的并发请求"><a href="#接口的并发请求" class="headerlink" title="接口的并发请求"></a>接口的并发请求</h3><p><a href="http://php.net/manual/zh/book.curl.php" target="_blank" rel="noopener">Client URL 库</a><br><br><br><br></p>
<h1 id="9-数据库缓存层的优化"><a href="#9-数据库缓存层的优化" class="headerlink" title="9.数据库缓存层的优化"></a>9.数据库缓存层的优化</h1><h2 id="1-数据库缓存"><a href="#1-数据库缓存" class="headerlink" title="1.数据库缓存"></a>1.数据库缓存</h2><p>MySQL等一些常见的关系型数据库的数据都存储在磁盘当中,在高并发场景下,业务应用对MySQL产生的增删改查的操作造成巨大的I/O开销和查询压力,这无疑对数据库和服务器都是一种巨大的压力,为了解决此类问题,缓存数据的概念应运而生.<br>极大地解决数据库服务器的压力,提高应用数据的响应速度<br>常见的缓存形式:内存缓存,文件缓存.</p>
<h2 id="2-为什么要使用缓存"><a href="#2-为什么要使用缓存" class="headerlink" title="2.为什么要使用缓存"></a>2.为什么要使用缓存</h2><p>缓存数据是为了让客户端很少甚至不访问数据库服务器进行数据的查询,高并发下,能最大程度地降低对数据库服务器的访问压力.</p>
<h2 id="3-缓存需要考虑的内容"><a href="#3-缓存需要考虑的内容" class="headerlink" title="3.缓存需要考虑的内容"></a>3.缓存需要考虑的内容</h2><p>缓存方式的选择:尽量缓存到内存中,降低IO开销<br>缓存场景的选择:经常需要修改的数据<br>缓存数据的实时性:结合实际场景,更新缓存中的数据<br>保证缓存数据的稳定性</p>
<h2 id="4-MySQL自带的查询缓存-只做了解"><a href="#4-MySQL自带的查询缓存-只做了解" class="headerlink" title="4.MySQL自带的查询缓存(只做了解)"></a>4.MySQL自带的查询缓存(只做了解)</h2><p>优点:极大地降低CPD使用率<br>缺点:限制比较多,颗粒度太小.<br>query_cache_type:查询缓存类型,有0 1 2三个取值,0不使用查询缓存,1始终使用查询缓存,2按需使用查询缓存.<br>查询缓存可以看做是SQL文本和查询结果的映射.<br>第二次查询的SQL和第一次查询的SQL完全相同,则会使用缓存.<br><code>show status like &#39;qcache_hits&#39;;</code>查看命中次数<br>表结构和数据发生改变时,查询缓存中的数据不在有效.<br>清理缓存:<code>flush query cache; reset query cache; flush tables;</code></p>
<h2 id="5-使用memcache缓存查询数据"><a href="#5-使用memcache缓存查询数据" class="headerlink" title="5.使用memcache缓存查询数据"></a>5.使用memcache缓存查询数据</h2><p>对于大型站点,如果没有中间缓存层,当流量打入数据库是,即便有之前的几层为我们挡住一部分流量,但是在大并发的情况下,还是会有大量请求涌入数据层,这样对于数据库服务器的压力冲击很大,响应速度也会下降,因此添加中间缓存层很有必要.<br>memcached是一套分布式的高速缓存系统,由LiveJournal的Brad Fitzpatrick开发,但目前被许多网站使用以提升网站的访问速度,尤其对于一些大型的,需要频繁访问数据库的网站,访问速度提升效果十分显著.<br>工作原理:memcache是一个高性能的分布式的内存对象缓存系统,通过在内存里维护一个统一的巨大的hash表,它能够用来存储各种格式的数据,包括图像,视频,文件以及数据库检索的结果等.简单的说就是将数据调用到内存,然后从内存中读取,从而大大提高读取速度.<br>工作流程:先检查客户端的请求数据是否在memcached中,如有,直接把请求数据返回,不再对数据库进行任何操作;如果请求的数据不在memcached中,就去查数据库,把从数据库中获取的数据返回给客户端,同时把数据缓存一份到memcached中.如果数据过期则只能访问数据库.<br>方法:<code>get(key) set(key,val,expire) delete(key)</code><br>通用缓存机制:用 查询的方法名+参数 作为查询时的key value 对中的key值</p>
<h2 id="6-使用Redis缓存查询数据"><a href="#6-使用Redis缓存查询数据" class="headerlink" title="6.使用Redis缓存查询数据"></a>6.使用Redis缓存查询数据</h2><p>redis与memcache的性能相差不大,需要根据场景去选择使用哪一个.redis支持持久化,复杂的数据结构(string list set sort-set).<br>redis在2.0版本后增加了自己的VM特性,突破物理内存的限制<br>memcache可以修改最大可用内存,采用LRU算法<br>redis依赖客户端来实现分布式读写,依赖快照进行持久化,AOF增强了可靠性的同时,对性能有所影响<br>memcache本身没有数据冗余机制<br>memcache不支持持久化,通常做缓存,提升性能<br>memcache在并发场景下,用cas保证一致性<br>redis事务支持比较弱,只能保证事务中的每个操作连续执行<br>redis用于数据量较小的高性能操作和运算上<br>memcache 用于在动态系统中减少数据库负载,提升性能</p>
<h2 id="7-缓存其他数据"><a href="#7-缓存其他数据" class="headerlink" title="7.缓存其他数据"></a>7.缓存其他数据</h2><p>session存到缓存中,便于频繁的操作.<br><br><br><br></p>
<h1 id="10-MySQL数据层的优化"><a href="#10-MySQL数据层的优化" class="headerlink" title="10.MySQL数据层的优化"></a>10.MySQL数据层的优化</h1><h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><p>数据表数据类型的优化(根据空间和范围,按需选择数据类型,如人的年龄选tinyint)<br>索引的优化(在合适的字段上建立合适的索引,复合索引的前缀原则)<br>sql语句的优化(优化查询过程中的数据访问如使用limit符|不用*,长难句查询如切分查询|分解关联查询,特定类型的查询如优化count()|优化关联查询)<br>存储引擎的优化(推荐使用InnoDB)<br>数据表结构设计的优化(分区操作,分库分表)<br>数据库服务器架构的优化(主从复制,读写分离,双主热备,负载均衡 MyCat数据库中间件实现负载均衡)</p>
<h1 id="11-web服务器的负载均衡"><a href="#11-web服务器的负载均衡" class="headerlink" title="11.web服务器的负载均衡"></a>11.web服务器的负载均衡</h1><h2 id="1-七层负载均衡的实现"><a href="#1-七层负载均衡的实现" class="headerlink" title="1.七层负载均衡的实现"></a>1.七层负载均衡的实现</h2><p>基于URL等应用层信息的负载均衡<br>nginx的proxy是它一个很强大的功能,实现了7层负载均衡<br>功能强大,性能卓越,运行稳定<br>配置简单灵活<br>能够自动剔除工作不正常的后端服务器<br>上传文件使用异步模式<br>支持多种分配策略,可以分配权重,分配方式灵活</p>
<h3 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡:"></a>Nginx负载均衡:</h3><p>内置策略 | 扩展策略<br>内置策略:IP Hash | 加权轮询<br>扩展策略:fair策略 | 通用hash | 一致性hash<br>加权轮询:首先将请求都分给高权重的机器,直到该机器的权值降到了比其他机器低,才开始将请求分给下一个高权重的机器<br>当所有的后端机器都down掉是,nginx会立即将所有机器的标志位清成初始状态,以避免造成所有的机器都处在timeout的状态<br>IP hash策略:nginx内置的另一个负载均衡的策略,流程和轮询很类似,只是其中的算法和具体的策略有些变化.一种变相的轮询策略.<br>fair策略:根据后端服务器的响应时间判断负载情况,从中选出负载最轻的机器进行分流.<br>通用hash和一致性hash策略:通用hash比较简单,可以以nginx内置的变量为key进行hash;一致性hash采用了nginx内置的一致性hash环,支持memcache<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	upstream cluster&#123;	</span><br><span class="line">		#添加策略 权重 等等</span><br><span class="line">		server srv1;</span><br><span class="line">		server srv2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server&#123;</span><br><span class="line">		listen 80;</span><br><span class="line">		location /&#123;</span><br><span class="line">			proxy_pass http://cluster;</span><br><span class="line">		&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-四层负载均衡"><a href="#2-四层负载均衡" class="headerlink" title="2.四层负载均衡"></a>2.四层负载均衡</h2><p>通过报文中的目标地址和端口,再加上负载均衡设备设置的服务器选择方式,决定最终选择的内容服务器.<br>LVS实现服务器集群负载均衡有三种方式, NAT, DR和TUN</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PHP/" rel="tag"># PHP</a>
          
            <a href="/tags/网站优化/" rel="tag"># 网站优化</a>
          
            <a href="/tags/负载均衡/" rel="tag"># 负载均衡</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/03/PHP基础之算法和数据结构/" rel="next" title="PHP基础之算法和数据结构">
                <i class="fa fa-chevron-left"></i> PHP基础之算法和数据结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/29/Git服务器搭建/" rel="prev" title="Git服务器搭建">
                Git服务器搭建 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.JPG"
                alt="Fullegg" />
            
              <p class="site-author-name" itemprop="name">Fullegg</p>
              <p class="site-description motion-element" itemprop="description">写博客总结知识</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/fullegg233" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:fullegg233@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-高并发和大流量解决方案"><span class="nav-number">1.</span> <span class="nav-text">1.高并发和大流量解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-回顾"><span class="nav-number">1.1.</span> <span class="nav-text">1.回顾</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-高并发架构相关概念"><span class="nav-number">1.2.</span> <span class="nav-text">2.高并发架构相关概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-高并发解决方案案例"><span class="nav-number">1.3.</span> <span class="nav-text">3.高并发解决方案案例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-web资源防盗链"><span class="nav-number">2.</span> <span class="nav-text">2.web资源防盗链</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-什么是防盗链"><span class="nav-number">2.1.</span> <span class="nav-text">1.什么是防盗链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-防盗链的工作原理"><span class="nav-number">2.2.</span> <span class="nav-text">2.防盗链的工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-通过Referer实现防盗链"><span class="nav-number">2.3.</span> <span class="nav-text">3.通过Referer实现防盗链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-通过第三方模块加密签名实现防盗链"><span class="nav-number">2.4.</span> <span class="nav-text">4.通过第三方模块加密签名实现防盗链</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-减少HTTP请求次数"><span class="nav-number">3.</span> <span class="nav-text">3.减少HTTP请求次数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-为什么要减少HTTP请求"><span class="nav-number">3.1.</span> <span class="nav-text">1.为什么要减少HTTP请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-减少HTTP请求的方式"><span class="nav-number">3.2.</span> <span class="nav-text">2.减少HTTP请求的方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-浏览器缓存和压缩优化技术"><span class="nav-number">4.</span> <span class="nav-text">4.浏览器缓存和压缩优化技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-HTTP缓存机制"><span class="nav-number">4.1.</span> <span class="nav-text">1.HTTP缓存机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-本地缓存"><span class="nav-number">4.2.</span> <span class="nav-text">2.本地缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-协商缓存"><span class="nav-number">4.3.</span> <span class="nav-text">3.协商缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-缓存策略的选择"><span class="nav-number">4.4.</span> <span class="nav-text">4.缓存策略的选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-nginx配置缓存策略"><span class="nav-number">4.5.</span> <span class="nav-text">5.nginx配置缓存策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-前端代码和资源的压缩"><span class="nav-number">4.6.</span> <span class="nav-text">6.前端代码和资源的压缩</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-CDN加速"><span class="nav-number">5.</span> <span class="nav-text">5.CDN加速</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-CDN相关概念"><span class="nav-number">5.1.</span> <span class="nav-text">1.CDN相关概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-使用CDN的优势"><span class="nav-number">5.2.</span> <span class="nav-text">2.使用CDN的优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-CDN工作原理"><span class="nav-number">5.3.</span> <span class="nav-text">3.CDN工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-CDN使用场景"><span class="nav-number">5.4.</span> <span class="nav-text">4.CDN使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-实现"><span class="nav-number">5.5.</span> <span class="nav-text">5.实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-部署独立图片服务器"><span class="nav-number">6.</span> <span class="nav-text">6.部署独立图片服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-独立的必要性"><span class="nav-number">6.1.</span> <span class="nav-text">1.独立的必要性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-采用独立域名"><span class="nav-number">6.2.</span> <span class="nav-text">2.采用独立域名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-独立后的问题"><span class="nav-number">6.3.</span> <span class="nav-text">3.独立后的问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-动态语言静态化"><span class="nav-number">7.</span> <span class="nav-text">7.动态语言静态化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-什么是动态语言静态化"><span class="nav-number">7.1.</span> <span class="nav-text">1.什么是动态语言静态化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-为什么要静态化"><span class="nav-number">7.2.</span> <span class="nav-text">2.为什么要静态化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-静态化的实现方式"><span class="nav-number">7.3.</span> <span class="nav-text">3.静态化的实现方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-动态语言的并发处理"><span class="nav-number">8.</span> <span class="nav-text">8.动态语言的并发处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-什么是进程-线程-协程"><span class="nav-number">8.1.</span> <span class="nav-text">1.什么是进程,线程,协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程-process"><span class="nav-number">8.1.1.</span> <span class="nav-text">进程(process)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的三态模型-运行-就绪-阻塞"><span class="nav-number">8.1.2.</span> <span class="nav-text">进程的三态模型(运行 就绪 阻塞)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的五态模型"><span class="nav-number">8.1.3.</span> <span class="nav-text">进程的五态模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">8.1.4.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程"><span class="nav-number">8.1.5.</span> <span class="nav-text">协程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-线程与进程的区别"><span class="nav-number">8.2.</span> <span class="nav-text">2.线程与进程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-线程与协程的区别"><span class="nav-number">8.3.</span> <span class="nav-text">3.线程与协程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-什么是多进程-多线程"><span class="nav-number">8.4.</span> <span class="nav-text">4.什么是多进程,多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-同步阻塞模型"><span class="nav-number">8.5.</span> <span class="nav-text">5.同步阻塞模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤"><span class="nav-number">8.5.1.</span> <span class="nav-text">步骤:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-异步非阻塞模型"><span class="nav-number">8.6.</span> <span class="nav-text">6.异步非阻塞模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-PHP并发编程实践"><span class="nav-number">8.7.</span> <span class="nav-text">7.PHP并发编程实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PHP的swoole扩展"><span class="nav-number">8.7.1.</span> <span class="nav-text">PHP的swoole扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列"><span class="nav-number">8.7.2.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用解耦"><span class="nav-number">8.7.3.</span> <span class="nav-text">应用解耦</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流量削峰"><span class="nav-number">8.7.4.</span> <span class="nav-text">流量削峰</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日志处理"><span class="nav-number">8.7.5.</span> <span class="nav-text">日志处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息通讯"><span class="nav-number">8.7.6.</span> <span class="nav-text">消息通讯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见消息队列产品"><span class="nav-number">8.7.7.</span> <span class="nav-text">常见消息队列产品</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口的并发请求"><span class="nav-number">8.7.8.</span> <span class="nav-text">接口的并发请求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-数据库缓存层的优化"><span class="nav-number">9.</span> <span class="nav-text">9.数据库缓存层的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-数据库缓存"><span class="nav-number">9.1.</span> <span class="nav-text">1.数据库缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-为什么要使用缓存"><span class="nav-number">9.2.</span> <span class="nav-text">2.为什么要使用缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-缓存需要考虑的内容"><span class="nav-number">9.3.</span> <span class="nav-text">3.缓存需要考虑的内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-MySQL自带的查询缓存-只做了解"><span class="nav-number">9.4.</span> <span class="nav-text">4.MySQL自带的查询缓存(只做了解)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-使用memcache缓存查询数据"><span class="nav-number">9.5.</span> <span class="nav-text">5.使用memcache缓存查询数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-使用Redis缓存查询数据"><span class="nav-number">9.6.</span> <span class="nav-text">6.使用Redis缓存查询数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-缓存其他数据"><span class="nav-number">9.7.</span> <span class="nav-text">7.缓存其他数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-MySQL数据层的优化"><span class="nav-number">10.</span> <span class="nav-text">10.MySQL数据层的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#优化方向"><span class="nav-number">10.1.</span> <span class="nav-text">优化方向</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-web服务器的负载均衡"><span class="nav-number">11.</span> <span class="nav-text">11.web服务器的负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-七层负载均衡的实现"><span class="nav-number">11.1.</span> <span class="nav-text">1.七层负载均衡的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx负载均衡"><span class="nav-number">11.1.1.</span> <span class="nav-text">Nginx负载均衡:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-四层负载均衡"><span class="nav-number">11.2.</span> <span class="nav-text">2.四层负载均衡</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fullegg</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>